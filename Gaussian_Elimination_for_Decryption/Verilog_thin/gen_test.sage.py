
# This file was *autogenerated* from the file gen_test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_67 = Integer(67); _sage_const_1p0 = RealNumber('1.0'); _sage_const_8 = Integer(8); _sage_const_83 = Integer(83); _sage_const_16 = Integer(16)#example sage gen_test.sage 4 8 2
import sys


def ffi_elt_set_random(GF2m):
    # use as input the object of GF2m
    m = GF2m.degree()
    rng = ''
    for i in range(m):
        rng += str(randint(_sage_const_0 , _sage_const_1 ))
    tmp = list( int(s) for s in rng[_sage_const_0 :m] )
    return GF2m(tmp)

def ffi_vec_directsum(ffi_vec_M, ffi_vec_N):
    return ffi_vec_M + ffi_vec_N

def ffi_vec_set_random_full_rank(GF2m, dim):
    #create the full-rank matrix M with size dim*m
    m = GF2m.degree()
    
    while True:
        M = matrix(GF(_sage_const_2 ), dim, m)
        for i in range(dim):
            r = ffi_elt_set_random(GF2m).polynomial().list()
            for j in range(len(r)):
                M[i,j] = r[j]
        if M.rank() == dim:
            break

    ffi_vec = dim*[_sage_const_0 ]
    for i in range(dim):
        ffi_vec[i] = GF2m(list(M[i]))
    return ffi_vec


def ffi_vec_set_random_from_support(F, n):
    #generate a vector with n GF2m elements with support F
    ffi_vec = n*[_sage_const_0 ]
    d = len(F)

    i = _sage_const_0 
    while i < d: #occupy randomly d positions of ffi_vec with coordinates of F
        rnd = randint(_sage_const_0 , n-_sage_const_1 )
        if ffi_vec[rnd] == _sage_const_0 :
            ffi_vec[rnd] = F[i]
            i += _sage_const_1 

    for i in range(n): #occupy the remaining n-d positions of ffi_vec with random linear combinations of coordinates of F
        if ffi_vec[i] == _sage_const_0 :
            tmp = _sage_const_0 
            for j in range(d):
                if randint(_sage_const_0 ,_sage_const_1 ) == _sage_const_1 :
                    tmp += F[j]
            ffi_vec[i] = tmp
        
    return ffi_vec  

if __name__ == "__main__":
	#k*l matrix processed by digit*l systolic arrry
	# k = int(sys.argv[1])
	# l = int(sys.argv[2])
	# digit = int(sys.argv[3])
    n = _sage_const_83 
    m = _sage_const_67 
    r = _sage_const_7 
    d = _sage_const_8 
    rd = r*d

    k = _sage_const_2 *n  
    l = _sage_const_2 *m
    digit = _sage_const_16 

    k1 = ceil(_sage_const_1p0 *k/digit)*digit

    MS = MatrixSpace(GF(_sage_const_2 ), k1, l)

    # generate two matrices A and B from vector space F
    R = GF(_sage_const_2 )['x']
    for p in R.polynomials(m):
        if p.is_irreducible():
            print(p)
            break
    ffi_elt = GF(_sage_const_2 **m,'x', modulus=p)
 
    E = ffi_vec_set_random_full_rank(ffi_elt, rd)
    F = ffi_vec_set_random_full_rank(ffi_elt, r)
    EF = ffi_vec_directsum(E, F) # EF = E union F
    ffi_vec_A = ffi_vec_set_random_from_support(F, rd) # n or rd
    ffi_vec_B = ffi_vec_set_random_from_support(EF, n)

    # formulate the target 2n*2m matrix M
    A = matrix(GF(_sage_const_2 ),rd,m) # n or rd
    for i in range(rd): # n or rd
        tmp = ffi_elt(ffi_vec_A[i]).polynomial().list()
        for j in range(len(tmp)):
            A[i,j] = tmp[j]
    
    B = matrix(GF(_sage_const_2 ),n,m)
    for i in range(n):
        tmp = ffi_elt(ffi_vec_B[i]).polynomial().list()
        for j in range(len(tmp)):
            B[i,j] = tmp[j]
        
    M = block_matrix([ [A, A], [B, _sage_const_0 ] ])
    ZERO = zero_matrix(GF(_sage_const_2 ), k1-M.nrows(), l)
    M = block_matrix([ [M], [ZERO] ]) # make sure M.row() is a multiple of digit
    M_rref = M.echelon_form()

    intersect = _sage_const_0  # EF intersects F = F
    for r in M_rref.rows():
        if r[_sage_const_0 :M_rref.ncols()/_sage_const_2 ] == zero_vector(GF(_sage_const_2 ),M_rref.ncols()/_sage_const_2 ) and r[M_rref.ncols()/_sage_const_2 :M_rref.ncols()] != zero_vector(GF(_sage_const_2 ),M_rref.ncols()/_sage_const_2 ):
            intersect = intersect+_sage_const_1 
    # print (intersect) # dim(A \intersect B)


    # while True:
    #     M = MS.random_element()  
    #     for i in range(digit,k1):
    #         M[i] = matrix(1,l) #zero padding of the last few rows
    #     M_rref = M.echelon_form()

    #     intersect = 0
    #     for r in M_rref.rows():
    #         if r[0:M_rref.ncols()/2] == zero_vector(GF(2),M_rref.ncols()/2) and r[M_rref.ncols()/2:M_rref.ncols()] != zero_vector(GF(2),M_rref.ncols()/2):
    #             intersect = intersect+1
    #     print intersect
    #     if M_rref.rank() != k and M_rref[0,0:k/2] != matrix(1,k/2) and intersect != 0: # not full-rank, and the first half of the first row is non-zero, and intersection exists
    #         break

    #write data_in file - row wise
    with open("data.in", "w") as f:
      for r in M.rows():
        for i in r:
          f.write("{0}".format(i))
        f.write("\n")

    f.close()

    print ("Input matrix:")
    print (M)
    print ("")

