
# This file was *autogenerated* from the file verify_test.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_79 = Integer(79); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_113 = Integer(113); _sage_const_67 = Integer(67); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_97 = Integer(97); _sage_const_83 = Integer(83); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_193 = Integer(193); _sage_const_15 = Integer(15); _sage_const_189 = Integer(189); _sage_const_211 = Integer(211); _sage_const_6 = Integer(6)#!/usr/bin/sage

#
# This file is part of the testbench, which generates a random input GF(2m)[z] 
# polynomial which fits the block RAM data format.
# 
# Copyright (C) 2019
# Authors: David Jingwei Hu <davidhu@ntu.edu.sg>
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

#usage: sage verify_test.sage 'ROLLO-I-128' '3' 'mem_A.txt' 'mem_B.txt' 'mem_C.txt' (it extracts two memory files as 'mem_A.txt' and 'mem_B.txt' and compare the result with that of 'mem_C.txt')

import sys


SL = str(sys.argv[_sage_const_1 ])
d = int(sys.argv[_sage_const_2 ])
mem_A = str(sys.argv[_sage_const_3 ])
mem_B = str(sys.argv[_sage_const_4 ])
mem_C = str(sys.argv[_sage_const_5 ])

#set_random_seed(12345)

############################################################################
#
#   initialize the system parameters
#
############################################################################
#ROLLO-I setups
if SL == 'ROLLO-I-128':
  n = _sage_const_83 
  m = _sage_const_67 

  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_83 ] = _sage_const_1 
  P_list[_sage_const_7 ] = _sage_const_1 
  P_list[_sage_const_4 ] = _sage_const_1 
  P_list[_sage_const_2 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_67 ] = _sage_const_1 
  f_list[_sage_const_5 ] = _sage_const_1 
  f_list[_sage_const_2 ] = _sage_const_1 
  f_list[_sage_const_1 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

elif SL == 'ROLLO-I-192':
  n = _sage_const_97 
  m = _sage_const_79 
  
  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_97 ] = _sage_const_1 
  P_list[_sage_const_6 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_79 ] = _sage_const_1 
  f_list[_sage_const_9 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

elif SL == 'ROLLO-I-256': 
  n = _sage_const_113 
  m = _sage_const_97 

  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_113 ] = _sage_const_1 
  P_list[_sage_const_9 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_97 ] = _sage_const_1 
  f_list[_sage_const_6 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

#ROLLO-II setups
elif SL == 'ROLLO-II-128':
  n = _sage_const_189 
  m = _sage_const_83 
  
  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_189 ] = _sage_const_1 
  P_list[_sage_const_6 ] = _sage_const_1 
  P_list[_sage_const_5 ] = _sage_const_1 
  P_list[_sage_const_2 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_83 ] = _sage_const_1 
  f_list[_sage_const_7 ] = _sage_const_1 
  f_list[_sage_const_4 ] = _sage_const_1 
  f_list[_sage_const_2 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

elif SL == 'ROLLO-II-192':
  n = _sage_const_193 
  m = _sage_const_97 
  
  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_193 ] = _sage_const_1 
  P_list[_sage_const_15 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_97 ] = _sage_const_1 
  f_list[_sage_const_6 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

elif SL == 'ROLLO-II-256':
  n = _sage_const_211 
  m = _sage_const_97 
  
  P_list = (n+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial P
  P_list[_sage_const_211 ] = _sage_const_1 
  P_list[_sage_const_11 ] = _sage_const_1 
  P_list[_sage_const_10 ] = _sage_const_1 
  P_list[_sage_const_8 ] = _sage_const_1 
  P_list[_sage_const_0 ] = _sage_const_1 

  f_list = (m+_sage_const_1 )*[_sage_const_0 ] # sparse list for polynomial f
  f_list[_sage_const_97 ] = _sage_const_1 
  f_list[_sage_const_6 ] = _sage_const_1 
  f_list[_sage_const_0 ] = _sage_const_1 

else:
  print ('Input Errors')  
  exit()

depth = ceil(n/d) # memory depth
width = m*d # memory width (bit-level)


#construct the GF(2m)(e.g, ffi_elt) based on the irreducible polynomial f
ffi_elt = GF(_sage_const_2 **m, 'x', modulus = f_list)
PR_F_2m = PolynomialRing(ffi_elt, names=('z',)); (z,) = PR_F_2m._first_ngens(1)

#construct the polynomial ring over GF(2m)[z] based on the ring polynomial P
nonzero_idx = [i for i, e in enumerate(P_list) if e != _sage_const_0 ]
P = _sage_const_0 
for i in nonzero_idx:
  P += z**i

ffi_vec = QuotientRing(PR_F_2m, PR_F_2m.ideal(P))


A1 = ffi_vec.random_element()
B1 = ffi_vec.random_element()
############################################################################
#
#   extract the data from the input memory files and then verify the correctness
#
############################################################################
  
# read mem_A file - line wise, d GF(2m) coefficients in each line, every coefficient is LSB first
rows = []
with open(mem_A, "r") as f:
    for line in f:
        if line.startswith("//"): #strip off the comment lines
            continue

        line = line.replace('\r', '') #handle the ending symbol '\r\n' in MS-Windows format

        for i in range(d):
            row = []
            coeff = line[i*m:i*m+m]
            for c in coeff:
                row = row + [int(c)]
            rows.append(row)
A = ffi_vec(rows)


# read mem_B file
rows = []
with open(mem_B, "r") as f:
    for line in f:
        if line.startswith("//"): #strip off the comment lines
            continue

        line = line.replace('\r', '') #handle the ending symbol '\r\n' in MS-Windows format
        for i in range(d):
            row = []
            coeff = line[i*m:i*m+m]
            for c in coeff:
                row = row + [int(c)]
            rows.append(row)
B = ffi_vec(rows)

# read mem_C file
rows = []
with open(mem_C, "r") as f:
    for line in f:
        if line.startswith("//"): #strip off the comment lines
            continue

        line = line.replace('\r', '') #handle the ending symbol '\r\n' in MS-Windows format
        for i in range(d):
            row = []
            coeff = line[i*m:i*m+m]
            for c in coeff:
                row = row + [int(c)]
            rows.append(row)
C = ffi_vec(rows)

if C == A*B:
    print ("OK")
else: 
    print ("ERROR")
    exit(-_sage_const_1 )

